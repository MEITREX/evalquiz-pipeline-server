from evalquiz_pipeline_server.evalquiz_config_iteration.internal_pipeline_modules.question_generation.question_type_composer.multiple_choice_composer import (
    MultipleChoiceComposer,
)
from evalquiz_pipeline_server.evalquiz_config_iteration.internal_pipeline_modules.question_generation.question_type_composer.multiple_response_composer import (
    MultipleResponseComposer,
)
from evalquiz_pipeline_server.evalquiz_config_iteration.internal_pipeline_modules.question_generation.question_type_composer.question_type_composer import (
    QuestionTypeComposer,
)
from evalquiz_proto.shared.generated import (
    Capability,
    CourseSettings,
    Question,
    GenerationSettings,
    QuestionType,
    EducationalObjective,
    Relationship,
)


class MessageComposer:
    def __init__(
        self,
        course_settings: CourseSettings,
        generation_settings: GenerationSettings,
        max_previous_messages: int = 3,
    ) -> None:
        self.course_settings = course_settings
        self.generation_settings = generation_settings
        self.max_previous_messages = max_previous_messages
        self.question_type_composers: dict[QuestionType, QuestionTypeComposer] = {
            QuestionType.MULTIPLE_CHOICE: MultipleChoiceComposer(),
            QuestionType.MULTIPLE_RESPONSE: MultipleResponseComposer(),
        }
        self.educational_objective_explanations: dict[EducationalObjective, str] = {
            EducationalObjective.KNOW_AND_UNDERSTAND: "Know and understand",
            EducationalObjective.APPLY: "Apply",
            EducationalObjective.ANALYZE: "Analyze",
            EducationalObjective.SYNTHESIZE: "Synthesize",
            EducationalObjective.EVALUATE: "Evaluate",
            EducationalObjective.INNOVATE: "Innovate",
        }
        self.relationship_translations: dict[Relationship, str] = {
            Relationship.SIMILARITY: "the similarities between",
            Relationship.DIFFERENCES: "the differences between",
            Relationship.ORDER: "the order of",
            Relationship.COMPLEX: "the complex relationship between",
        }

    def compose(
        self,
        question: Question,
        capabilites: list[Capability],
        filtered_text: str,
        previous_messages: list[dict[str, str]],
    ) -> list[dict[str, str]]:
        return (
            [self.compose_system_message(question, capabilites)]
            + self.compose_few_shot_examples(question, previous_messages)
            + [self.compose_query_message(question, filtered_text)]
        )

    def compose_system_message(
        self, question: Question, capabilites: list[Capability]
    ) -> dict[str, str]:
        question_type_composer = self.question_type_composers[question.question_type]
        return {
            "role": "system",
            "content": """You are a question generation assistant that supports generating questions in multiple fixed formats.
Your goal is to use the given markdown formatted text input to generate a question of the following format:

<result>
"""
            + question_type_composer.compose_system_message_instructions()
            + """</result>

Give your answer in the specified format at all cost!

The question generated by you serves the purpose of helping a student to self-assess, which skills they have acquired.
A student who can answer the generated question successfully should have acquired the following skill set:
"""
            + self.compose_capability_message(capabilites)
            + """Double-check that the question supports strengthening the previously given skills.

You can assume that the student already has acquired the following skills:
"""
            + self.compose_capability_message(self.course_settings.required_capabilites)
            + """Here is more information about the ALL_CAPS formatted instructions used in the skill descriptions:
"""
            + self.compose_relevant_educational_objective_explanations(capabilites),
        }

    def compose_few_shot_examples(
        self, question: Question, previous_messages: list[dict[str, str]]
    ) -> list[dict[str, str]]:
        max_previous_messages_and_responses = self.max_previous_messages * 2
        question_type_few_shot_examples = self.question_type_composers[
            question.question_type
        ].compose_few_shot_examples()
        return (
            previous_messages[:max_previous_messages_and_responses]
            + question_type_few_shot_examples
        )

    def compose_query_message(
        self, question: Question, filtered_text: str
    ) -> dict[str, str]:
        question_type_query_message = self.question_type_composers[
            question.question_type
        ].compose_query_message(filtered_text)
        return question_type_query_message

    def compose_capability_message(self, capabilites: list[Capability]) -> str:
        capability_message = ""
        for capability in capabilites:
            capability_text = (
                capability.educational_objective.name
                + " "
                + self.relationship_translations[capability.relationship]
                + ": "
                + ", ".join(capability.keywords)
            )
            capability_message += capability_text + "/n"
        capability_message += "/n"
        return capability_message

    def compose_relevant_educational_objective_explanations(
        self, capabilites: list[Capability]
    ) -> str:
        relevant_educational_objectives = [
            capability.educational_objective for capability in capabilites
        ]
        relevant_educational_objective_explanations = {
            educational_objective: self.educational_objective_explanations[
                educational_objective
            ]
            for educational_objective in relevant_educational_objectives
        }
        objective_explanations_message = ""
        for (
            educational_objective,
            explanation,
        ) in relevant_educational_objective_explanations.items():
            objective_explanations_message += (
                educational_objective.name + ": " + explanation + "/n"
            )
        objective_explanations_message += "/n"
        return objective_explanations_message
